# Challenge 04 - Hash Length Extension

**Category:** Cryptography
**Difficulty:** Intermediate
**Points:** 300
**Target:** Local Python Server / Custom Application

## Challenge Description

A web application uses HMAC-style authentication for API requests. The signature is generated by concatenating a secret key with the message and then hashing with MD5.

The developers thought: "If attackers don't know the secret, they can't forge signatures!" But they made a critical mistake - they used `md5(secret + message)` instead of proper HMAC.

Your mission is to exploit the hash length extension vulnerability to forge a valid signature for an admin request without knowing the secret key.

## Objectives

- Understand hash length extension attacks
- Learn how Merkle-Damgard hash functions work
- Use hash extension tools to forge signatures
- Escalate from user to admin privileges

## Target Information

- **Application:** Custom vulnerable API server
- **Hash Algorithm:** MD5 (vulnerable to length extension)
- **Original Request:** `user=guest&role=user`
- **Original Signature:** `9d5c73ef85594d34ec4438b7c97e51d8`
- **Goal:** Append `&role=admin` to the request and forge valid signature

## Getting Started

1. Create the vulnerable server (Python):

```python
#!/usr/bin/env python3
"""Vulnerable API Server - Hash Length Extension Challenge"""

from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import parse_qs, urlparse, unquote
import hashlib
import json

SECRET = "s3cr3tk3y"  # Unknown to attacker

class VulnerableAPI(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed = urlparse(self.path)
        params = parse_qs(parsed.query)

        if parsed.path == '/api/data':
            self.handle_api_request(params)
        elif parsed.path == '/api/flag':
            self.handle_flag_request(params)
        else:
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(b'''
                <h1>Hash Length Extension Challenge</h1>
                <p>Valid request example:</p>
                <code>/api/data?data=user=guest%26role=user&sig=9d5c73ef85594d34ec4438b7c97e51d8</code>
                <p>Goal: Access /api/flag with role=admin</p>
            ''')

    def verify_signature(self, data, signature):
        """VULNERABLE: Uses md5(secret + data) instead of HMAC"""
        expected = hashlib.md5((SECRET + data).encode()).hexdigest()
        return expected == signature

    def handle_api_request(self, params):
        data = params.get('data', [''])[0]
        sig = params.get('sig', [''])[0]

        if not self.verify_signature(data, sig):
            self.send_error(403, "Invalid signature")
            return

        # Parse the data
        parsed_data = {}
        for pair in data.split('&'):
            if '=' in pair:
                k, v = pair.split('=', 1)
                parsed_data[k] = v

        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        response = {"status": "success", "data": parsed_data}
        self.wfile.write(json.dumps(response).encode())

    def handle_flag_request(self, params):
        data = params.get('data', [''])[0]
        sig = params.get('sig', [''])[0]

        if not self.verify_signature(data, sig):
            self.send_error(403, "Invalid signature")
            return

        # Parse and check for admin role
        parsed_data = {}
        for pair in data.split('&'):
            if '=' in pair:
                k, v = pair.split('=', 1)
                parsed_data[k] = v

        if parsed_data.get('role') == 'admin':
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            response = {"flag": "FLAG{h4sh_l3ngth_3xt3ns10n_m4st3r}"}
            self.wfile.write(json.dumps(response).encode())
        else:
            self.send_response(403)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            response = {"error": "Admin access required"}
            self.wfile.write(json.dumps(response).encode())

if __name__ == '__main__':
    server = HTTPServer(('0.0.0.0', 8888), VulnerableAPI)
    print("Starting vulnerable server on port 8888...")
    server.serve_forever()
```

2. Run the server:
   ```bash
   python3 hash_extension_server.py
   ```

3. Test the original valid request:
   ```bash
   curl "http://localhost:8888/api/data?data=user%3Dguest%26role%3Duser&sig=9d5c73ef85594d34ec4438b7c97e51d8"
   ```

---

## Hints

<details>
<summary>Hint 1 (Cost: -30 points)</summary>

MD5, SHA1, and SHA256 are Merkle-Damgard construction hashes. This means:
- `hash(message)` produces an internal state
- If you know `hash(secret + message)`, you can continue hashing
- You can compute `hash(secret + message + padding + extension)` without knowing the secret!

</details>

<details>
<summary>Hint 2 (Cost: -40 points)</summary>

You need to know (or guess) the length of the secret to calculate correct padding.

The secret length is typically 8-16 characters. You may need to try multiple lengths.

Use a tool like `hashpump` or `hash_extender`:
```bash
# Install hashpump
git clone https://github.com/bwall/HashPump
cd HashPump && make && sudo make install

# Usage
hashpump -s <original_hash> -d <original_data> -a <append_data> -k <key_length>
```

</details>

<details>
<summary>Hint 3 (Cost: -60 points)</summary>

The secret is 9 characters long ("s3cr3tk3y").

Run:
```bash
hashpump -s 9d5c73ef85594d34ec4438b7c97e51d8 \
         -d "user=guest&role=user" \
         -a "&role=admin" \
         -k 9
```

This gives you:
- New signature
- New data (with padding bytes)

URL-encode the new data and make your request!

</details>

---

## Solution Walkthrough

<details>
<summary>Click to reveal full solution</summary>

### Step 1: Understand the Vulnerability

The server uses `md5(secret + data)` for authentication:

```python
def verify_signature(self, data, signature):
    expected = hashlib.md5((SECRET + data).encode()).hexdigest()
    return expected == signature
```

This is vulnerable because MD5 is a Merkle-Damgard hash. We can extend the hash without knowing the secret.

### Step 2: Gather Information

Known values:
- Original data: `user=guest&role=user`
- Original signature: `9d5c73ef85594d34ec4438b7c97e51d8`
- Secret length: Unknown (we'll brute force common lengths)

### Step 3: Install HashPump

```bash
# Clone and build
git clone https://github.com/bwall/HashPump
cd HashPump
make
sudo make install

# Or use Python library
pip install hashpumpy
```

### Step 4: Try Different Key Lengths

```bash
#!/bin/bash
# brute_key_length.sh

ORIGINAL_SIG="9d5c73ef85594d34ec4438b7c97e51d8"
ORIGINAL_DATA="user=guest&role=user"
APPEND_DATA="&role=admin"

for keylen in $(seq 1 20); do
    echo "Trying key length: $keylen"
    result=$(hashpump -s "$ORIGINAL_SIG" -d "$ORIGINAL_DATA" -a "$APPEND_DATA" -k $keylen)
    new_sig=$(echo "$result" | head -1)
    new_data=$(echo "$result" | tail -1)

    # URL encode the new data
    encoded_data=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$new_data', safe=''))")

    # Test the request
    response=$(curl -s "http://localhost:8888/api/flag?data=$encoded_data&sig=$new_sig")

    if echo "$response" | grep -q "FLAG"; then
        echo "SUCCESS with key length $keylen!"
        echo "$response"
        break
    fi
done
```

### Step 5: Use HashPump with Correct Key Length

```bash
hashpump -s 9d5c73ef85594d34ec4438b7c97e51d8 \
         -d "user=guest&role=user" \
         -a "&role=admin" \
         -k 9
```

Output:
```
New Signature: 3b2c51a139ed6b6e8c0fcd63b2d8e5a1
New Data: user=guest&role=user\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe8\x00\x00\x00\x00\x00\x00\x00&role=admin
```

### Step 6: Python Exploit Script

```python
#!/usr/bin/env python3
"""Hash Length Extension Attack"""

import hashpumpy
import urllib.parse
import requests

# Known values
original_sig = "9d5c73ef85594d34ec4438b7c97e51d8"
original_data = "user=guest&role=user"
append_data = "&role=admin"
server_url = "http://localhost:8888"

def try_key_length(key_len):
    """Attempt attack with given key length"""
    new_sig, new_data = hashpumpy.hashpump(
        original_sig,
        original_data,
        append_data,
        key_len
    )

    # URL encode the binary data
    encoded_data = urllib.parse.quote(new_data.decode('latin-1'), safe='')

    # Make request
    url = f"{server_url}/api/flag?data={encoded_data}&sig={new_sig}"
    response = requests.get(url)

    return response

# Try different key lengths
for key_len in range(1, 21):
    print(f"[*] Trying key length: {key_len}")
    response = try_key_length(key_len)

    if "FLAG" in response.text:
        print(f"[+] SUCCESS! Key length is {key_len}")
        print(f"[+] Response: {response.text}")
        break
    elif response.status_code == 200:
        print(f"[!] Valid signature but no flag: {response.text}")
else:
    print("[-] Failed to find valid key length")
```

### Step 7: Verify the Flag

```bash
# URL-encode the forged data (with padding bytes)
curl "http://localhost:8888/api/flag?data=user%3Dguest%26role%3Duser%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%E8%00%00%00%00%00%00%00%26role%3Dadmin&sig=3b2c51a139ed6b6e8c0fcd63b2d8e5a1"
```

Response:
```json
{"flag": "FLAG{h4sh_l3ngth_3xt3ns10n_m4st3r}"}
```

### How Hash Length Extension Works

1. **MD5 Padding**: Messages are padded to 512-bit blocks
   - Append 0x80
   - Append zeros until 448 bits
   - Append original message length (64 bits)

2. **Internal State**: MD5 processes blocks and maintains internal state
   - After processing `secret + message`, state is the hash output

3. **Extension**: We can continue from that state
   - We don't need to know the secret
   - We just need to know the hash and data length
   - We can append new data and compute valid hash

```
Original:  md5(secret + data)  →  hash_state
Extended:  md5(secret + data + padding + extension)  →  new_hash

We compute: hash_state + extension → new_hash
```

### Vulnerable vs Secure Authentication

```python
# VULNERABLE - Hash Length Extension possible
import hashlib
signature = hashlib.md5(secret + message).hexdigest()

# SECURE - Use HMAC
import hmac
signature = hmac.new(secret, message, hashlib.sha256).hexdigest()

# HMAC structure prevents length extension:
# HMAC(K, m) = H((K ⊕ opad) || H((K ⊕ ipad) || m))
```

### Affected Hash Functions

| Algorithm | Vulnerable | Reason |
|-----------|-----------|--------|
| MD5 | Yes | Merkle-Damgard |
| SHA-1 | Yes | Merkle-Damgard |
| SHA-256 | Yes | Merkle-Damgard |
| SHA-512 | Yes | Merkle-Damgard |
| SHA-3 | No | Sponge construction |
| BLAKE2 | No | Different design |

### Prevention

1. **Use HMAC**: `hmac.new(key, msg, hashlib.sha256)`
2. **Use SHA-3**: Resistant to length extension
3. **Hash(secret + hash(message))**: Double hashing
4. **Proper API authentication**: OAuth, JWT (properly implemented)

</details>

---

## Flag

```
FLAG{h4sh_l3ngth_3xt3ns10n_m4st3r}
```

**Flag Format:** `FLAG{...}`

## Skills Practiced

- Cryptographic attack understanding
- Hash function internals
- Tool usage (hashpump)
- Python scripting
- API authentication bypass

## Tools Used

- HashPump / hashpumpy
- Python requests library
- curl
- Hex editors

## Related Challenges

- [03 - Decode Me (Beginner)](../beginner/03-decode-me.md) - Basic encoding
- [07 - Ancient Secrets (Beginner)](../beginner/07-ancient-secrets.md) - Classical crypto
- [Cryptographic Oracle (Advanced)](../advanced/03-cryptographic-oracle.md) - Advanced crypto

## References

- [Wikipedia - Length Extension Attack](https://en.wikipedia.org/wiki/Length_extension_attack)
- [HashPump Tool](https://github.com/bwall/HashPump)
- [HMAC Specification](https://datatracker.ietf.org/doc/html/rfc2104)
- [Merkle-Damgard Construction](https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction)
